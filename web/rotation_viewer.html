<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rotation Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
        }

        header {
            background: #16213e;
            padding: 1rem 2rem;
            text-align: center;
            border-bottom: 2px solid #0f3460;
        }

        header h1 {
            font-size: 1.5rem;
            font-weight: 500;
        }

        .container {
            display: flex;
            height: calc(100vh - 60px);
            padding: 1rem;
            gap: 1rem;
        }

        .sidebar {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            flex-shrink: 0;
        }

        .panel {
            background: #16213e;
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid #0f3460;
        }

        .panel h2 {
            font-size: 0.875rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #888;
            margin-bottom: 1rem;
        }

        .slider-group {
            margin-bottom: 1rem;
        }

        .slider-group:last-child {
            margin-bottom: 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .slider-label span:first-child {
            font-weight: 500;
        }

        .slider-value {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.875rem;
            color: #7ec8e3;
            min-width: 60px;
            text-align: right;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #0f3460;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #7ec8e3;
            cursor: pointer;
            transition: background 0.15s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #a8d8ea;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #7ec8e3;
            cursor: pointer;
            border: none;
        }

        .yaw-slider::-webkit-slider-thumb { background: #5b8dee; }
        .pitch-slider::-webkit-slider-thumb { background: #4ecdc4; }
        .roll-slider::-webkit-slider-thumb { background: #ff6b6b; }

        .sensor-yaw-slider::-webkit-slider-thumb { background: #a55eea; }
        .sensor-pitch-slider::-webkit-slider-thumb { background: #ff9f43; }
        .sensor-roll-slider::-webkit-slider-thumb { background: #26de81; }

        .sensor-yaw-slider::-moz-range-thumb { background: #a55eea; border: none; }
        .sensor-pitch-slider::-moz-range-thumb { background: #ff9f43; border: none; }
        .sensor-roll-slider::-moz-range-thumb { background: #26de81; border: none; }

        .fov-slider::-webkit-slider-thumb { background: #f5cd79; }
        .fov-slider::-moz-range-thumb { background: #f5cd79; border: none; }

        .point-slider::-webkit-slider-thumb { background: #00d9ff; }
        .point-slider::-moz-range-thumb { background: #00d9ff; border: none; }

        .matrix-display {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.8rem;
        }

        .matrix-row {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
        }

        .matrix-cell {
            width: 70px;
            text-align: right;
            color: #7ec8e3;
        }

        .matrix-brackets {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .bracket {
            font-size: 3rem;
            color: #444;
            line-height: 1;
        }

        .gimbal-warning {
            background: #ff6b6b22;
            border: 1px solid #ff6b6b;
            border-radius: 6px;
            padding: 0.75rem;
            margin-top: 1rem;
            display: none;
        }

        .gimbal-warning.visible {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .gimbal-warning-icon {
            font-size: 1.25rem;
        }

        .gimbal-warning-text {
            font-size: 0.8rem;
            color: #ff6b6b;
        }

        .canvas-container {
            flex: 1;
            background: #0d1b2a;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .axis-legend {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            background: rgba(22, 33, 62, 0.9);
            padding: 0.75rem 1rem;
            border-radius: 6px;
            font-size: 0.75rem;
        }

        .axis-legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .axis-legend-item:last-child {
            margin-bottom: 0;
        }

        .axis-color {
            width: 12px;
            height: 3px;
            border-radius: 1px;
        }

        .axis-x { background: #ff6b6b; }
        .axis-y { background: #4ecdc4; }
        .axis-z { background: #5b8dee; }

        .sensor-axis-x { background: #ff9f43; }
        .sensor-axis-y { background: #a55eea; }
        .sensor-axis-z { background: #26de81; }

        .fov-color { background: #f5cd79; }

        .point-color { background: #00d9ff; }

        .coord-display {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.75rem;
            line-height: 1.6;
        }

        .coord-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.25rem;
        }

        .coord-label {
            color: #888;
        }

        .coord-value {
            color: #7ec8e3;
        }

        .coord-section-title {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: #666;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
        }

        .coord-section-title:first-child {
            margin-top: 0;
        }

        .in-fov-yes {
            color: #26de81;
        }

        .in-fov-no {
            color: #ff6b6b;
        }

        .legend-section-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            color: #666;
            margin-top: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .legend-section-title:first-child {
            margin-top: 0;
        }

        .reset-btn {
            background: #0f3460;
            border: 1px solid #1a4b8c;
            color: #7ec8e3;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.875rem;
            width: 100%;
            transition: background 0.15s;
        }

        .reset-btn:hover {
            background: #1a4b8c;
        }

        .info-text {
            font-size: 0.75rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .checkbox-group {
            margin-bottom: 0.75rem;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            font-size: 0.875rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #7ec8e3;
            cursor: pointer;
        }

        .checkbox-divider {
            border-top: 1px solid #0f3460;
            margin: 0.75rem 0;
        }
    </style>
</head>
<body>
    <header>
        <h1>3D Rotation Visualizer</h1>
    </header>

    <div class="container">
        <div class="sidebar">
            <div class="panel">
                <h2>Controls</h2>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Yaw (Z)</span>
                        <span class="slider-value" id="yaw-value">0.0°</span>
                    </div>
                    <input type="range" id="yaw" class="yaw-slider" min="-180" max="180" value="0" step="0.1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Pitch (Y)</span>
                        <span class="slider-value" id="pitch-value">0.0°</span>
                    </div>
                    <input type="range" id="pitch" class="pitch-slider" min="-90" max="90" value="0" step="0.1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Roll (X)</span>
                        <span class="slider-value" id="roll-value">0.0°</span>
                    </div>
                    <input type="range" id="roll" class="roll-slider" min="-180" max="180" value="0" step="0.1">
                </div>

                <button class="reset-btn" id="reset-btn">Reset Platform</button>
                <p class="info-text">Drag canvas to orbit camera</p>
            </div>

            <div class="panel">
                <h2>Sensor Orientation</h2>

                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="roll-stabilization">
                        Roll Stabilization
                    </label>
                </div>
                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="horizon-pitch">
                        Horizon-Relative Pitch
                    </label>
                </div>
                <div class="checkbox-divider"></div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Sensor Yaw (Z)</span>
                        <span class="slider-value" id="sensor-yaw-value">0.0°</span>
                    </div>
                    <input type="range" id="sensor-yaw" class="sensor-yaw-slider" min="-180" max="180" value="0" step="0.1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Sensor Pitch (Y)</span>
                        <span class="slider-value" id="sensor-pitch-value">0.0°</span>
                    </div>
                    <input type="range" id="sensor-pitch" class="sensor-pitch-slider" min="-90" max="90" value="0" step="0.1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Sensor Roll (X)</span>
                        <span class="slider-value" id="sensor-roll-value">0.0°</span>
                    </div>
                    <input type="range" id="sensor-roll" class="sensor-roll-slider" min="-180" max="180" value="0" step="0.1">
                </div>

                <button class="reset-btn" id="reset-sensor-btn">Reset Sensor</button>
            </div>

            <div class="panel">
                <h2>Sensor Field of View</h2>

                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="show-fov">
                        Show FOV
                    </label>
                </div>
                <div class="checkbox-divider"></div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Azimuth Min</span>
                        <span class="slider-value" id="fov-az-min-value">-30.0°</span>
                    </div>
                    <input type="range" id="fov-az-min" class="fov-slider" min="-90" max="0" value="-30" step="1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Azimuth Max</span>
                        <span class="slider-value" id="fov-az-max-value">30.0°</span>
                    </div>
                    <input type="range" id="fov-az-max" class="fov-slider" min="0" max="90" value="30" step="1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Elevation Min</span>
                        <span class="slider-value" id="fov-el-min-value">-20.0°</span>
                    </div>
                    <input type="range" id="fov-el-min" class="fov-slider" min="-90" max="0" value="-20" step="1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Elevation Max</span>
                        <span class="slider-value" id="fov-el-max-value">20.0°</span>
                    </div>
                    <input type="range" id="fov-el-max" class="fov-slider" min="0" max="90" value="20" step="1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Range</span>
                        <span class="slider-value" id="fov-range-value">2.0</span>
                    </div>
                    <input type="range" id="fov-range" class="fov-slider" min="0.5" max="5.0" value="2.0" step="0.1">
                </div>
            </div>

            <div class="panel">
                <h2>World Point</h2>

                <div class="checkbox-group">
                    <label>
                        <input type="checkbox" id="show-point">
                        Show Point
                    </label>
                </div>
                <div class="checkbox-divider"></div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>North (X)</span>
                        <span class="slider-value" id="point-x-value">2.0</span>
                    </div>
                    <input type="range" id="point-x" class="point-slider" min="-5.0" max="5.0" value="2.0" step="0.1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>East (Y)</span>
                        <span class="slider-value" id="point-y-value">0.0</span>
                    </div>
                    <input type="range" id="point-y" class="point-slider" min="-5.0" max="5.0" value="0.0" step="0.1">
                </div>

                <div class="slider-group">
                    <div class="slider-label">
                        <span>Down (Z)</span>
                        <span class="slider-value" id="point-z-value">0.0</span>
                    </div>
                    <input type="range" id="point-z" class="point-slider" min="-5.0" max="5.0" value="0.0" step="0.1">
                </div>
            </div>

            <div class="panel" id="point-coords-panel" style="display: none;">
                <h2>Point Coordinates</h2>
                <div class="coord-display">
                    <div class="coord-row">
                        <span class="coord-label">World NED:</span>
                        <span class="coord-value" id="coord-world"></span>
                    </div>
                    <div class="coord-row">
                        <span class="coord-label">Body Frame:</span>
                        <span class="coord-value" id="coord-body"></span>
                    </div>
                    <div class="coord-row">
                        <span class="coord-label">Sensor Frame:</span>
                        <span class="coord-value" id="coord-sensor"></span>
                    </div>

                    <div class="coord-section-title">Sensor View</div>
                    <div class="coord-row">
                        <span class="coord-label">Azimuth:</span>
                        <span class="coord-value" id="coord-azimuth"></span>
                    </div>
                    <div class="coord-row">
                        <span class="coord-label">Elevation:</span>
                        <span class="coord-value" id="coord-elevation"></span>
                    </div>
                    <div class="coord-row">
                        <span class="coord-label">Range:</span>
                        <span class="coord-value" id="coord-range"></span>
                    </div>
                    <div class="coord-row">
                        <span class="coord-label">In FOV:</span>
                        <span class="coord-value" id="coord-in-fov"></span>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>Platform Rotation Matrix</h2>
                <div class="matrix-brackets">
                    <span class="bracket">[</span>
                    <div class="matrix-display" id="matrix-display">
                        <div class="matrix-row">
                            <span class="matrix-cell" id="m00">1.000</span>
                            <span class="matrix-cell" id="m01">0.000</span>
                            <span class="matrix-cell" id="m02">0.000</span>
                        </div>
                        <div class="matrix-row">
                            <span class="matrix-cell" id="m10">0.000</span>
                            <span class="matrix-cell" id="m11">1.000</span>
                            <span class="matrix-cell" id="m12">0.000</span>
                        </div>
                        <div class="matrix-row">
                            <span class="matrix-cell" id="m20">0.000</span>
                            <span class="matrix-cell" id="m21">0.000</span>
                            <span class="matrix-cell" id="m22">1.000</span>
                        </div>
                    </div>
                    <span class="bracket">]</span>
                </div>

                <div class="gimbal-warning" id="gimbal-warning">
                    <span class="gimbal-warning-icon">&#x26A0;</span>
                    <span class="gimbal-warning-text">Gimbal Lock! Pitch at ±90° causes loss of one degree of freedom.</span>
                </div>
            </div>

            <div class="panel">
                <h2>Platform to Sensor Matrix</h2>
                <div class="matrix-brackets">
                    <span class="bracket">[</span>
                    <div class="matrix-display" id="sensor-matrix-display">
                        <div class="matrix-row">
                            <span class="matrix-cell" id="sm00">1.000</span>
                            <span class="matrix-cell" id="sm01">0.000</span>
                            <span class="matrix-cell" id="sm02">0.000</span>
                        </div>
                        <div class="matrix-row">
                            <span class="matrix-cell" id="sm10">0.000</span>
                            <span class="matrix-cell" id="sm11">1.000</span>
                            <span class="matrix-cell" id="sm12">0.000</span>
                        </div>
                        <div class="matrix-row">
                            <span class="matrix-cell" id="sm20">0.000</span>
                            <span class="matrix-cell" id="sm21">0.000</span>
                            <span class="matrix-cell" id="sm22">1.000</span>
                        </div>
                    </div>
                    <span class="bracket">]</span>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas"></canvas>
            <div class="axis-legend">
                <div class="legend-section-title">Platform</div>
                <div class="axis-legend-item">
                    <div class="axis-color axis-x"></div>
                    <span>X North (Roll)</span>
                </div>
                <div class="axis-legend-item">
                    <div class="axis-color axis-y"></div>
                    <span>Y East (Pitch)</span>
                </div>
                <div class="axis-legend-item">
                    <div class="axis-color axis-z"></div>
                    <span>Z Down (Yaw)</span>
                </div>
                <div class="legend-section-title">Sensor</div>
                <div class="axis-legend-item">
                    <div class="axis-color sensor-axis-x"></div>
                    <span>Sensor X</span>
                </div>
                <div class="axis-legend-item">
                    <div class="axis-color sensor-axis-y"></div>
                    <span>Sensor Y</span>
                </div>
                <div class="axis-legend-item">
                    <div class="axis-color sensor-axis-z"></div>
                    <span>Sensor Z</span>
                </div>
                <div class="legend-section-title">Field of View</div>
                <div class="axis-legend-item">
                    <div class="axis-color fov-color"></div>
                    <span>FOV Volume</span>
                </div>
                <div class="legend-section-title">World Point</div>
                <div class="axis-legend-item">
                    <div class="axis-color point-color"></div>
                    <span>Target Point</span>
                </div>
            </div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // DOM Elements - Platform
        const canvas = document.getElementById('canvas');
        const yawSlider = document.getElementById('yaw');
        const pitchSlider = document.getElementById('pitch');
        const rollSlider = document.getElementById('roll');
        const yawValue = document.getElementById('yaw-value');
        const pitchValue = document.getElementById('pitch-value');
        const rollValue = document.getElementById('roll-value');
        const resetBtn = document.getElementById('reset-btn');
        const gimbalWarning = document.getElementById('gimbal-warning');

        // DOM Elements - Sensor
        const sensorYawSlider = document.getElementById('sensor-yaw');
        const sensorPitchSlider = document.getElementById('sensor-pitch');
        const sensorRollSlider = document.getElementById('sensor-roll');
        const sensorYawValue = document.getElementById('sensor-yaw-value');
        const sensorPitchValue = document.getElementById('sensor-pitch-value');
        const sensorRollValue = document.getElementById('sensor-roll-value');
        const resetSensorBtn = document.getElementById('reset-sensor-btn');
        const rollStabilizationCheckbox = document.getElementById('roll-stabilization');
        const horizonPitchCheckbox = document.getElementById('horizon-pitch');

        // DOM Elements - FOV
        const showFovCheckbox = document.getElementById('show-fov');
        const fovAzMinSlider = document.getElementById('fov-az-min');
        const fovAzMaxSlider = document.getElementById('fov-az-max');
        const fovElMinSlider = document.getElementById('fov-el-min');
        const fovElMaxSlider = document.getElementById('fov-el-max');
        const fovRangeSlider = document.getElementById('fov-range');
        const fovAzMinValue = document.getElementById('fov-az-min-value');
        const fovAzMaxValue = document.getElementById('fov-az-max-value');
        const fovElMinValue = document.getElementById('fov-el-min-value');
        const fovElMaxValue = document.getElementById('fov-el-max-value');
        const fovRangeValue = document.getElementById('fov-range-value');

        // DOM Elements - World Point
        const showPointCheckbox = document.getElementById('show-point');
        const pointXSlider = document.getElementById('point-x');
        const pointYSlider = document.getElementById('point-y');
        const pointZSlider = document.getElementById('point-z');
        const pointXValue = document.getElementById('point-x-value');
        const pointYValue = document.getElementById('point-y-value');
        const pointZValue = document.getElementById('point-z-value');
        const pointCoordsPanel = document.getElementById('point-coords-panel');
        const coordWorld = document.getElementById('coord-world');
        const coordBody = document.getElementById('coord-body');
        const coordSensor = document.getElementById('coord-sensor');
        const coordAzimuth = document.getElementById('coord-azimuth');
        const coordElevation = document.getElementById('coord-elevation');
        const coordRange = document.getElementById('coord-range');
        const coordInFov = document.getElementById('coord-in-fov');

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0d1b2a);

        const camera = new THREE.PerspectiveCamera(
            50,
            canvas.clientWidth / canvas.clientHeight,
            0.1,
            1000
        );
        // Position camera for NED view: above and behind, looking at origin
        camera.position.set(3, 4, 5);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        // OrbitControls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 2;
        controls.maxDistance = 15;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 5);
        scene.add(directionalLight);

        // Colors - Platform
        const colors = {
            x: 0xff6b6b,  // Red - X/North
            y: 0x4ecdc4,  // Cyan - Y/East
            z: 0x5b8dee   // Blue - Z/Down
        };

        // Colors - Sensor
        const sensorColors = {
            x: 0xff9f43,  // Orange - Sensor X
            y: 0xa55eea,  // Purple - Sensor Y
            z: 0x26de81   // Lime - Sensor Z
        };

        // NED to Three.js coordinate transform
        // NED: X=North(forward), Y=East(right), Z=Down
        // Three.js: X=right, Y=up, Z=toward camera
        // Mapping: NED X -> TJS -Z (forward into scene)
        //          NED Y -> TJS +X (right)
        //          NED Z -> TJS -Y (down)
        const T_ned_to_tjs = [
            [0,  1,  0],   // TJS X = NED Y
            [0,  0, -1],   // TJS Y = -NED Z
            [-1, 0,  0]    // TJS Z = -NED X
        ];

        // Matrix multiplication for 3x3 matrices
        function matmul3(A, B) {
            const result = [[0,0,0], [0,0,0], [0,0,0]];
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    for (let k = 0; k < 3; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        }

        // Create arrow helper for axis
        function createAxis(dir, color, length = 2) {
            const arrow = new THREE.ArrowHelper(
                dir.normalize(),
                new THREE.Vector3(0, 0, 0),
                length,
                color,
                0.3,
                0.15
            );
            return arrow;
        }

        // Create coordinate frame in NED orientation (mapped to Three.js display coords)
        function createNEDFrame(opacity = 1) {
            const group = new THREE.Group();

            // NED axes mapped to Three.js display coordinates
            // NED X (North) -> TJS (0, 0, -1)
            // NED Y (East)  -> TJS (1, 0, 0)
            // NED Z (Down)  -> TJS (0, -1, 0)
            const xAxis = createAxis(new THREE.Vector3(0, 0, -1), colors.x);  // North - forward
            const yAxis = createAxis(new THREE.Vector3(1, 0, 0), colors.y);   // East - right
            const zAxis = createAxis(new THREE.Vector3(0, -1, 0), colors.z);  // Down

            if (opacity < 1) {
                [xAxis, yAxis, zAxis].forEach(arrow => {
                    arrow.line.material.transparent = true;
                    arrow.line.material.opacity = opacity;
                    arrow.cone.material.transparent = true;
                    arrow.cone.material.opacity = opacity;
                });
            }

            group.add(xAxis, yAxis, zAxis);
            return group;
        }

        // Create sensor coordinate frame with distinct colors
        function createSensorFrame(opacity = 1) {
            const group = new THREE.Group();

            // Sensor axes mapped to Three.js display coordinates (same mapping as NED)
            const xAxis = createAxis(new THREE.Vector3(0, 0, -1), sensorColors.x);
            const yAxis = createAxis(new THREE.Vector3(1, 0, 0), sensorColors.y);
            const zAxis = createAxis(new THREE.Vector3(0, -1, 0), sensorColors.z);

            if (opacity < 1) {
                [xAxis, yAxis, zAxis].forEach(arrow => {
                    arrow.line.material.transparent = true;
                    arrow.line.material.opacity = opacity;
                    arrow.cone.material.transparent = true;
                    arrow.cone.material.opacity = opacity;
                });
            }

            group.add(xAxis, yAxis, zAxis);
            return group;
        }

        // Reference frame (semi-transparent, static) - shows NED orientation
        const referenceFrame = createNEDFrame(0.25);
        scene.add(referenceFrame);

        // Platform rotating frame - will be updated with rotation matrix
        const rotatingFrame = createNEDFrame(1);
        scene.add(rotatingFrame);

        // Sensor frame - rotates with platform plus its own relative rotation
        const sensorFrame = createSensorFrame(1);
        scene.add(sensorFrame);

        // Grid helper - horizontal plane (XY in NED = ground)
        const gridHelper = new THREE.GridHelper(6, 12, 0x333355, 0x222244);
        // GridHelper is on XZ plane by default, no rotation needed for our NED mapping
        scene.add(gridHelper);

        // FOV materials
        const fovMaterial = new THREE.MeshBasicMaterial({
            color: 0xf7d794,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const fovEdgeMaterial = new THREE.LineBasicMaterial({
            color: 0xf5cd79,
            transparent: true,
            opacity: 0.6
        });

        // Resolution for spherical cap (degrees per segment)
        const FOV_RESOLUTION_DEGREES = 5;

        // FOV mesh and edges (will be added to sensorFrame)
        let fovMesh = null;
        let fovEdges = null;

        // World point sphere
        const pointGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const pointMaterialInFov = new THREE.MeshBasicMaterial({ color: 0x00d9ff });
        const pointMaterialOutFov = new THREE.MeshBasicMaterial({ color: 0x00d9ff, transparent: true, opacity: 0.4 });
        const worldPointSphere = new THREE.Mesh(pointGeometry, pointMaterialInFov);
        worldPointSphere.visible = false;
        scene.add(worldPointSphere);

        // Store current rotation matrices for point calculation (updated by updateVisualization)
        let currentR_platform = [[1,0,0], [0,1,0], [0,0,1]];
        let currentR_sensor_world = [[1,0,0], [0,1,0], [0,0,1]];

        // Compute FOV corner in Three.js coordinates from azimuth/elevation/range
        function computeFOVCornerThreeJS(azimuth, elevation, range) {
            // Compute in NED: X=forward, Y=right, Z=down
            const cosEl = Math.cos(elevation);
            const sinEl = Math.sin(elevation);
            const cosAz = Math.cos(azimuth);
            const sinAz = Math.sin(azimuth);

            const nedX = range * cosEl * cosAz;
            const nedY = range * cosEl * sinAz;
            const nedZ = range * sinEl;

            // NED to Three.js: TJS_X=NED_Y, TJS_Y=-NED_Z, TJS_Z=-NED_X
            return new THREE.Vector3(nedY, -nedZ, -nedX);
        }

        // Compute segment counts for spherical cap based on angular span
        function computeSegmentCounts(azMin, azMax, elMin, elMax, resolution) {
            const azSpanDeg = (azMax - azMin) * 180 / Math.PI;
            const elSpanDeg = (elMax - elMin) * 180 / Math.PI;
            return {
                azSegments: Math.max(2, Math.ceil(azSpanDeg / resolution)),
                elSegments: Math.max(2, Math.ceil(elSpanDeg / resolution))
            };
        }

        // Generate a 2D grid of points on sphere surface at constant range
        function generateSphericalCapGrid(azMin, azMax, elMin, elMax, range, azSegments, elSegments) {
            const grid = [];
            for (let i = 0; i <= azSegments; i++) {
                const row = [];
                const t = i / azSegments;
                const az = azMin + t * (azMax - azMin);
                for (let j = 0; j <= elSegments; j++) {
                    const s = j / elSegments;
                    const el = elMin + s * (elMax - elMin);
                    row.push(computeFOVCornerThreeJS(az, el, range));
                }
                grid.push(row);
            }
            return grid;
        }

        // Generate triangles for spherical cap (2 triangles per grid cell)
        function generateCapTriangles(grid, azSegments, elSegments) {
            const vertices = [];
            for (let i = 0; i < azSegments; i++) {
                for (let j = 0; j < elSegments; j++) {
                    // Grid cell corners
                    const v00 = grid[i][j];
                    const v10 = grid[i + 1][j];
                    const v01 = grid[i][j + 1];
                    const v11 = grid[i + 1][j + 1];

                    // Triangle 1: v00, v01, v11
                    vertices.push(v00.x, v00.y, v00.z);
                    vertices.push(v01.x, v01.y, v01.z);
                    vertices.push(v11.x, v11.y, v11.z);

                    // Triangle 2: v00, v11, v10
                    vertices.push(v00.x, v00.y, v00.z);
                    vertices.push(v11.x, v11.y, v11.z);
                    vertices.push(v10.x, v10.y, v10.z);
                }
            }
            return vertices;
        }

        // Generate triangles from apex to each curved boundary edge (4 sides)
        function generateSideTriangles(grid, apex, azSegments, elSegments) {
            const vertices = [];

            // Top edge (elMin): apex to grid[i][0] - grid[i+1][0]
            for (let i = 0; i < azSegments; i++) {
                const v0 = grid[i][0];
                const v1 = grid[i + 1][0];
                vertices.push(apex.x, apex.y, apex.z);
                vertices.push(v0.x, v0.y, v0.z);
                vertices.push(v1.x, v1.y, v1.z);
            }

            // Bottom edge (elMax): apex to grid[i+1][elSegments] - grid[i][elSegments]
            for (let i = 0; i < azSegments; i++) {
                const v0 = grid[i + 1][elSegments];
                const v1 = grid[i][elSegments];
                vertices.push(apex.x, apex.y, apex.z);
                vertices.push(v0.x, v0.y, v0.z);
                vertices.push(v1.x, v1.y, v1.z);
            }

            // Left edge (azMin): apex to grid[0][j+1] - grid[0][j]
            for (let j = 0; j < elSegments; j++) {
                const v0 = grid[0][j + 1];
                const v1 = grid[0][j];
                vertices.push(apex.x, apex.y, apex.z);
                vertices.push(v0.x, v0.y, v0.z);
                vertices.push(v1.x, v1.y, v1.z);
            }

            // Right edge (azMax): apex to grid[azSegments][j] - grid[azSegments][j+1]
            for (let j = 0; j < elSegments; j++) {
                const v0 = grid[azSegments][j];
                const v1 = grid[azSegments][j + 1];
                vertices.push(apex.x, apex.y, apex.z);
                vertices.push(v0.x, v0.y, v0.z);
                vertices.push(v1.x, v1.y, v1.z);
            }

            return vertices;
        }

        // Generate line segments for wireframe edges
        function generateCurvedEdges(grid, apex, azSegments, elSegments) {
            const vertices = [];

            // 4 straight edges from apex to corners
            const topLeft = grid[0][0];
            const topRight = grid[azSegments][0];
            const bottomLeft = grid[0][elSegments];
            const bottomRight = grid[azSegments][elSegments];

            vertices.push(apex.x, apex.y, apex.z, topLeft.x, topLeft.y, topLeft.z);
            vertices.push(apex.x, apex.y, apex.z, topRight.x, topRight.y, topRight.z);
            vertices.push(apex.x, apex.y, apex.z, bottomLeft.x, bottomLeft.y, bottomLeft.z);
            vertices.push(apex.x, apex.y, apex.z, bottomRight.x, bottomRight.y, bottomRight.z);

            // Top curved edge (elMin)
            for (let i = 0; i < azSegments; i++) {
                const v0 = grid[i][0];
                const v1 = grid[i + 1][0];
                vertices.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);
            }

            // Bottom curved edge (elMax)
            for (let i = 0; i < azSegments; i++) {
                const v0 = grid[i][elSegments];
                const v1 = grid[i + 1][elSegments];
                vertices.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);
            }

            // Left curved edge (azMin)
            for (let j = 0; j < elSegments; j++) {
                const v0 = grid[0][j];
                const v1 = grid[0][j + 1];
                vertices.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);
            }

            // Right curved edge (azMax)
            for (let j = 0; j < elSegments; j++) {
                const v0 = grid[azSegments][j];
                const v1 = grid[azSegments][j + 1];
                vertices.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);
            }

            return vertices;
        }

        // Create FOV geometry with spherical cap
        function createFOVGeometry(azMin, azMax, elMin, elMax, range) {
            const apex = new THREE.Vector3(0, 0, 0);

            // Compute segment counts based on angular span
            const { azSegments, elSegments } = computeSegmentCounts(
                azMin, azMax, elMin, elMax, FOV_RESOLUTION_DEGREES
            );

            // Generate grid of points on sphere surface
            const grid = generateSphericalCapGrid(azMin, azMax, elMin, elMax, range, azSegments, elSegments);

            // Generate all triangles
            const capVertices = generateCapTriangles(grid, azSegments, elSegments);
            const sideVertices = generateSideTriangles(grid, apex, azSegments, elSegments);

            // Combine all vertices
            const allVertices = new Float32Array([...sideVertices, ...capVertices]);

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(allVertices, 3));
            geometry.computeVertexNormals();

            // Generate edge geometry
            const edgeVertices = new Float32Array(generateCurvedEdges(grid, apex, azSegments, elSegments));
            const edgeGeometry = new THREE.BufferGeometry();
            edgeGeometry.setAttribute('position', new THREE.BufferAttribute(edgeVertices, 3));

            return { geometry, edgeGeometry };
        }

        // Update FOV visualization
        function updateFOV() {
            // Update value displays (always, regardless of checkbox)
            fovAzMinValue.textContent = `${parseFloat(fovAzMinSlider.value).toFixed(1)}°`;
            fovAzMaxValue.textContent = `${parseFloat(fovAzMaxSlider.value).toFixed(1)}°`;
            fovElMinValue.textContent = `${parseFloat(fovElMinSlider.value).toFixed(1)}°`;
            fovElMaxValue.textContent = `${parseFloat(fovElMaxSlider.value).toFixed(1)}°`;
            fovRangeValue.textContent = parseFloat(fovRangeSlider.value).toFixed(1);

            // Remove existing FOV mesh and edges
            if (fovMesh) {
                sensorFrame.remove(fovMesh);
                fovMesh.geometry.dispose();
                fovMesh = null;
            }
            if (fovEdges) {
                sensorFrame.remove(fovEdges);
                fovEdges.geometry.dispose();
                fovEdges = null;
            }

            // Only show if checkbox is checked
            if (!showFovCheckbox.checked) {
                return;
            }

            // Get FOV parameters
            const azMin = degToRad(parseFloat(fovAzMinSlider.value));
            const azMax = degToRad(parseFloat(fovAzMaxSlider.value));
            const elMin = degToRad(parseFloat(fovElMinSlider.value));
            const elMax = degToRad(parseFloat(fovElMaxSlider.value));
            const range = parseFloat(fovRangeSlider.value);

            // Create geometry
            const { geometry, edgeGeometry } = createFOVGeometry(azMin, azMax, elMin, elMax, range);

            // Create mesh and edges
            fovMesh = new THREE.Mesh(geometry, fovMaterial);
            fovEdges = new THREE.LineSegments(edgeGeometry, fovEdgeMaterial);

            // Add to sensor frame so it rotates with sensor
            sensorFrame.add(fovMesh);
            sensorFrame.add(fovEdges);
        }

        // Update world point visualization
        function updateWorldPoint() {
            // Update slider value displays
            pointXValue.textContent = parseFloat(pointXSlider.value).toFixed(1);
            pointYValue.textContent = parseFloat(pointYSlider.value).toFixed(1);
            pointZValue.textContent = parseFloat(pointZSlider.value).toFixed(1);

            const showPoint = showPointCheckbox.checked;
            worldPointSphere.visible = showPoint;
            pointCoordsPanel.style.display = showPoint ? 'block' : 'none';

            if (!showPoint) {
                return;
            }

            // Get world NED coordinates
            const P_world = [
                parseFloat(pointXSlider.value),
                parseFloat(pointYSlider.value),
                parseFloat(pointZSlider.value)
            ];

            // Transform to body frame: P_body = R_platform^T * P_world
            const R_platform_T = transposeMatrix3(currentR_platform);
            const P_body = transformPointByMatrix(P_world, R_platform_T);

            // Transform to sensor frame: P_sensor = R_sensor_world^T * P_world
            const R_sensor_world_T = transposeMatrix3(currentR_sensor_world);
            const P_sensor = transformPointByMatrix(P_world, R_sensor_world_T);

            // Compute spherical coordinates in sensor frame
            const spherical = computeSphericalCoords(P_sensor);
            const azimuthDeg = spherical.azimuth * 180 / Math.PI;
            const elevationDeg = spherical.elevation * 180 / Math.PI;

            // Check FOV containment (only meaningful if point is in front of sensor)
            const inFront = P_sensor[0] > 0;
            const inFOV = inFront && showFovCheckbox.checked &&
                          checkFOVContainment(spherical.azimuth, spherical.elevation, spherical.range);

            // Update coordinate display
            coordWorld.textContent = `[${formatNumber(P_world[0])}, ${formatNumber(P_world[1])}, ${formatNumber(P_world[2])}]`;
            coordBody.textContent = `[${formatNumber(P_body[0])}, ${formatNumber(P_body[1])}, ${formatNumber(P_body[2])}]`;
            coordSensor.textContent = `[${formatNumber(P_sensor[0])}, ${formatNumber(P_sensor[1])}, ${formatNumber(P_sensor[2])}]`;
            coordAzimuth.textContent = `${azimuthDeg.toFixed(1)}°`;
            coordElevation.textContent = `${elevationDeg.toFixed(1)}°`;
            coordRange.textContent = spherical.range.toFixed(3);

            if (!showFovCheckbox.checked) {
                coordInFov.textContent = 'N/A';
                coordInFov.className = 'coord-value';
            } else if (!inFront) {
                coordInFov.textContent = 'Behind';
                coordInFov.className = 'coord-value in-fov-no';
            } else if (inFOV) {
                coordInFov.textContent = 'Yes ✓';
                coordInFov.className = 'coord-value in-fov-yes';
            } else {
                coordInFov.textContent = 'No';
                coordInFov.className = 'coord-value in-fov-no';
            }

            // Update sphere position (convert NED to Three.js)
            // NED to Three.js: TJS_X=NED_Y, TJS_Y=-NED_Z, TJS_Z=-NED_X
            worldPointSphere.position.set(P_world[1], -P_world[2], -P_world[0]);

            // Update sphere material based on FOV containment
            if (inFOV) {
                worldPointSphere.material = pointMaterialInFov;
            } else {
                worldPointSphere.material = pointMaterialOutFov;
            }
        }

        // Euler to rotation matrix (ported from Python)
        // Convention: Tait-Bryan Z-Y-X (yaw-pitch-roll), intrinsic, active
        // R = Rz(yaw) * Ry(pitch) * Rx(roll)
        function eulerToMatrix(roll, pitch, yaw) {
            const cu = Math.cos(roll), su = Math.sin(roll);
            const cv = Math.cos(pitch), sv = Math.sin(pitch);
            const cw = Math.cos(yaw), sw = Math.sin(yaw);

            return [
                [cv*cw, su*sv*cw - cu*sw, su*sw + cu*sv*cw],
                [cv*sw, cu*cw + su*sv*sw, cu*sv*sw - su*cw],
                [-sv,   su*cv,            cu*cv           ]
            ];
        }

        // Apply rotation matrix to Three.js object
        function applyRotationMatrix(object, R) {
            const m = new THREE.Matrix4();
            m.set(
                R[0][0], R[0][1], R[0][2], 0,
                R[1][0], R[1][1], R[1][2], 0,
                R[2][0], R[2][1], R[2][2], 0,
                0, 0, 0, 1
            );
            object.setRotationFromMatrix(m);
        }

        // Check for gimbal lock
        function isGimbalLocked(pitchDeg, tolerance = 1) {
            return Math.abs(Math.abs(pitchDeg) - 90) < tolerance;
        }

        // Convert degrees to radians
        function degToRad(deg) {
            return deg * Math.PI / 180;
        }

        // Format number for display
        function formatNumber(n) {
            return n.toFixed(3).replace(/^-0\.000$/, '0.000');
        }

        // Transpose a 3x3 matrix
        function transposeMatrix3(R) {
            return [
                [R[0][0], R[1][0], R[2][0]],
                [R[0][1], R[1][1], R[2][1]],
                [R[0][2], R[1][2], R[2][2]]
            ];
        }

        // Transform a 3D point by a rotation matrix
        function transformPointByMatrix(P, R) {
            return [
                R[0][0] * P[0] + R[0][1] * P[1] + R[0][2] * P[2],
                R[1][0] * P[0] + R[1][1] * P[1] + R[1][2] * P[2],
                R[2][0] * P[0] + R[2][1] * P[1] + R[2][2] * P[2]
            ];
        }

        // Compute spherical coordinates in sensor frame (NED convention)
        // Returns azimuth (positive=right), elevation (positive=down), range
        function computeSphericalCoords(P) {
            const x = P[0], y = P[1], z = P[2];
            const range = Math.sqrt(x * x + y * y + z * z);
            const azimuth = Math.atan2(y, x);
            const groundRange = Math.sqrt(x * x + y * y);
            const elevation = Math.atan2(z, groundRange);
            return { azimuth, elevation, range };
        }

        // Check if spherical coords are within FOV bounds
        function checkFOVContainment(az, el, range) {
            const azMin = degToRad(parseFloat(fovAzMinSlider.value));
            const azMax = degToRad(parseFloat(fovAzMaxSlider.value));
            const elMin = degToRad(parseFloat(fovElMinSlider.value));
            const elMax = degToRad(parseFloat(fovElMaxSlider.value));
            const fovRange = parseFloat(fovRangeSlider.value);

            return (az >= azMin && az <= azMax &&
                    el >= elMin && el <= elMax &&
                    range <= fovRange);
        }

        // Update platform rotation matrix display
        function updateMatrixDisplay(matrix) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cell = document.getElementById(`m${i}${j}`);
                    cell.textContent = formatNumber(matrix[i][j]);
                }
            }
        }

        // Update sensor rotation matrix display
        function updateSensorMatrixDisplay(matrix) {
            for (let i = 0; i < 3; i++) {
                for (let j = 0; j < 3; j++) {
                    const cell = document.getElementById(`sm${i}${j}`);
                    cell.textContent = formatNumber(matrix[i][j]);
                }
            }
        }

        // Update visualization
        function updateVisualization() {
            // Platform angles
            const yawDeg = parseFloat(yawSlider.value);
            const pitchDeg = parseFloat(pitchSlider.value);
            const rollDeg = parseFloat(rollSlider.value);

            // Sensor angles (relative to platform)
            const sensorYawDeg = parseFloat(sensorYawSlider.value);
            const sensorPitchDeg = parseFloat(sensorPitchSlider.value);
            const sensorRollDeg = parseFloat(sensorRollSlider.value);

            // Update platform value displays
            yawValue.textContent = `${yawDeg.toFixed(1)}°`;
            pitchValue.textContent = `${pitchDeg.toFixed(1)}°`;
            rollValue.textContent = `${rollDeg.toFixed(1)}°`;

            // Update sensor value displays
            sensorYawValue.textContent = `${sensorYawDeg.toFixed(1)}°`;
            sensorPitchValue.textContent = `${sensorPitchDeg.toFixed(1)}°`;
            sensorRollValue.textContent = `${sensorRollDeg.toFixed(1)}°`;

            // Convert platform angles to radians
            const yaw = degToRad(yawDeg);
            const pitch = degToRad(pitchDeg);
            const roll = degToRad(rollDeg);

            // Convert sensor angles to radians
            const sensorYaw = degToRad(sensorYawDeg);
            const sensorPitch = degToRad(sensorPitchDeg);
            const sensorRoll = degToRad(sensorRollDeg);

            // Calculate platform rotation matrix in NED frame
            const R_platform = eulerToMatrix(roll, pitch, yaw);
            updateMatrixDisplay(R_platform);
            currentR_platform = R_platform;

            // Calculate sensor-relative rotation matrix (platform to sensor)
            const R_sensor_rel = eulerToMatrix(sensorRoll, sensorPitch, sensorYaw);
            updateSensorMatrixDisplay(R_sensor_rel);

            // Get stabilization flags
            const rollStab = rollStabilizationCheckbox.checked;
            const horizonPitchStab = horizonPitchCheckbox.checked;

            // Build platform contribution based on stabilization settings
            let R_platform_contrib;
            if (rollStab && horizonPitchStab) {
                // Only yaw affects sensor
                R_platform_contrib = eulerToMatrix(0, 0, yaw);
            } else if (rollStab) {
                // Yaw and pitch affect sensor (no roll)
                R_platform_contrib = eulerToMatrix(0, pitch, yaw);
            } else if (horizonPitchStab) {
                // Yaw and roll affect sensor (no pitch)
                R_platform_contrib = matmul3(
                    eulerToMatrix(0, 0, yaw),
                    eulerToMatrix(roll, 0, 0)
                );
            } else {
                // Full platform rotation (current behavior)
                R_platform_contrib = R_platform;
            }

            // Calculate combined sensor world rotation: R_sensor_world = R_platform_contrib * R_sensor_rel
            const R_sensor_world = matmul3(R_platform_contrib, R_sensor_rel);
            currentR_sensor_world = R_sensor_world;

            // Transform rotations to Three.js display coordinates
            const T = T_ned_to_tjs;
            const T_inv = [
                [0, 0, -1],
                [1, 0,  0],
                [0, -1, 0]
            ];

            // Platform visual rotation
            const R_platform_visual = matmul3(matmul3(T, R_platform), T_inv);
            applyRotationMatrix(rotatingFrame, R_platform_visual);

            // Sensor visual rotation (combined world rotation)
            const R_sensor_visual = matmul3(matmul3(T, R_sensor_world), T_inv);
            applyRotationMatrix(sensorFrame, R_sensor_visual);

            // Check for gimbal lock (platform)
            if (isGimbalLocked(pitchDeg)) {
                gimbalWarning.classList.add('visible');
            } else {
                gimbalWarning.classList.remove('visible');
            }

            // Update world point (depends on rotation matrices)
            updateWorldPoint();
        }

        // Event listeners - Platform
        yawSlider.addEventListener('input', updateVisualization);
        pitchSlider.addEventListener('input', updateVisualization);
        rollSlider.addEventListener('input', updateVisualization);

        resetBtn.addEventListener('click', () => {
            yawSlider.value = 0;
            pitchSlider.value = 0;
            rollSlider.value = 0;
            updateVisualization();
        });

        // Event listeners - Sensor
        sensorYawSlider.addEventListener('input', updateVisualization);
        sensorPitchSlider.addEventListener('input', updateVisualization);
        sensorRollSlider.addEventListener('input', updateVisualization);
        rollStabilizationCheckbox.addEventListener('change', updateVisualization);
        horizonPitchCheckbox.addEventListener('change', updateVisualization);

        resetSensorBtn.addEventListener('click', () => {
            sensorYawSlider.value = 0;
            sensorPitchSlider.value = 0;
            sensorRollSlider.value = 0;
            updateVisualization();
        });

        // Event listeners - FOV
        showFovCheckbox.addEventListener('change', () => { updateFOV(); updateWorldPoint(); });
        fovAzMinSlider.addEventListener('input', () => { updateFOV(); updateWorldPoint(); });
        fovAzMaxSlider.addEventListener('input', () => { updateFOV(); updateWorldPoint(); });
        fovElMinSlider.addEventListener('input', () => { updateFOV(); updateWorldPoint(); });
        fovElMaxSlider.addEventListener('input', () => { updateFOV(); updateWorldPoint(); });
        fovRangeSlider.addEventListener('input', () => { updateFOV(); updateWorldPoint(); });

        // Event listeners - World Point
        showPointCheckbox.addEventListener('change', updateWorldPoint);
        pointXSlider.addEventListener('input', updateWorldPoint);
        pointYSlider.addEventListener('input', updateWorldPoint);
        pointZSlider.addEventListener('input', updateWorldPoint);

        // Handle window resize
        function onWindowResize() {
            const container = canvas.parentElement;
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        }

        window.addEventListener('resize', onWindowResize);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Initialize
        updateVisualization();
        updateFOV();
        updateWorldPoint();
        onWindowResize();
        animate();
    </script>
</body>
</html>
